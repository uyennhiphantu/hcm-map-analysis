import os
import pandas as pd
import requests
import folium

BASE_2014 = "http://localhost:8004"
BASE_2025 = "http://localhost:8005"

POINTS_CSV = "points.csv"
DELTA_CSV = "matrix_delta.csv"

OUT_DIR = "route_maps"
os.makedirs(OUT_DIR, exist_ok=True)

TIMEOUT_SEC = 90

def decode_polyline6(s: str):
    """
    Decode Valhalla polyline (usually 6-digit precision).
    Return list of (lat, lon).
    """
    index, lat, lon = 0, 0, 0
    coordinates = []
    length = len(s)

    while index < length:
        shift, result = 0, 0
        while True:
            b = ord(s[index]) - 63
            index += 1
            result |= (b & 0x1f) << shift
            shift += 5
            if b < 0x20:
                break
        dlat = ~(result >> 1) if (result & 1) else (result >> 1)
        lat += dlat

        shift, result = 0, 0
        while True:
            b = ord(s[index]) - 63
            index += 1
            result |= (b & 0x1f) << shift
            shift += 5
            if b < 0x20:
                break
        dlng = ~(result >> 1) if (result & 1) else (result >> 1)
        lon += dlng

        coordinates.append((lat / 1e6, lon / 1e6))

    return coordinates

def get_point(points_df: pd.DataFrame, point_id: int) -> tuple[float, float]:
    row = points_df.loc[points_df["id"] == point_id]
    if row.empty:
        raise ValueError(f"Point id {point_id} not found in points_50.csv")
    return float(row.iloc[0]["lat"]), float(row.iloc[0]["lon"])

def route_coords(base_url: str, A: tuple[float, float], B: tuple[float, float]):
    """
    Robustly get route coordinates from Valhalla /route.

    Try:
      1) shape_format=geojson -> expects shape = {"type":"LineString","coordinates":[[lon,lat],...]}
      2) fallback: no shape_format -> shape is encoded polyline string
    """
    # Attempt GeoJSON
    payload = {
        "locations": [{"lat": A[0], "lon": A[1]}, {"lat": B[0], "lon": B[1]}],
        "costing": "auto",
        "directions_options": {"units": "kilometers"},
        "shape_format": "geojson",
    }
    r = requests.post(f"{base_url}/route", json=payload, timeout=TIMEOUT_SEC)
    r.raise_for_status()
    data = r.json()

    leg = data["trip"]["legs"][0]
    shape = leg.get("shape")

    # Case 1: GeoJSON dict
    if isinstance(shape, dict) and "coordinates" in shape:
        coords_lonlat = shape["coordinates"]
        coords_latlon = [(lat, lon) for lon, lat in coords_lonlat]
        return coords_latlon, data["trip"]["summary"]

    # Case 2: encoded polyline string
    if isinstance(shape, str):
        coords_latlon = decode_polyline6(shape)
        return coords_latlon, data["trip"]["summary"]

    # If neither works, try a fallback request without shape_format
    payload2 = {
        "locations": [{"lat": A[0], "lon": A[1]}, {"lat": B[0], "lon": B[1]}],
        "costing": "auto",
        "directions_options": {"units": "kilometers"},
    }
    r2 = requests.post(f"{base_url}/route", json=payload2, timeout=TIMEOUT_SEC)
    r2.raise_for_status()
    data2 = r2.json()
    leg2 = data2["trip"]["legs"][0]
    shape2 = leg2.get("shape")

    if isinstance(shape2, str):
        coords_latlon = decode_polyline6(shape2)
        return coords_latlon, data2["trip"]["summary"]

    raise RuntimeError(f"Unsupported shape format from {base_url}/route. shape type={type(shape)}")

def add_info_box(m: folium.Map, text: str):
    html = f"""
    <div style="
        position: fixed; top: 20px; right: 20px; z-index: 9999;
        background: white; padding: 10px 12px; border: 1px solid #ccc; border-radius: 6px;
        font-size: 13px; max-width: 360px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        white-space: pre-wrap;
    ">{text}</div>
    """
    m.get_root().html.add_child(folium.Element(html))

def make_map(A, B, coords14, coords25, meta_text: str, out_path: str):
    center = ((A[0] + B[0]) / 2, (A[1] + B[1]) / 2)
    m = folium.Map(location=center, zoom_start=12, control_scale=True)

    # 2014 solid
    folium.PolyLine(coords14, weight=5, opacity=0.85, tooltip="Route 2014").add_to(m)
    # 2025 dashed
    folium.PolyLine(coords25, weight=5, opacity=0.85, dash_array="10,6", tooltip="Route 2025").add_to(m)

    folium.Marker(A, tooltip="Source").add_to(m)
    folium.Marker(B, tooltip="Destination").add_to(m)

    add_info_box(m, meta_text)
    m.save(out_path)

def safe_num(x):
    return None if pd.isna(x) else float(x)

def main(top_k=3, metric="delta_time_s"):
    points = pd.read_csv(POINTS_CSV)
    delta = pd.read_csv(DELTA_CSV)

    # Only OD pairs that exist in both years + exclude self-loop
    cand = delta.dropna(subset=["time_s_2014", "time_s_2025", "distance_km_2014", "distance_km_2025", metric]).copy()
    cand = cand[cand["src"] != cand["dst"]]

    cand["abs_metric"] = cand[metric].abs()
    cand = cand.sort_values("abs_metric", ascending=False).head(top_k)

    if cand.empty:
        raise RuntimeError("No valid OD pairs found after filtering. Try a different metric or check null rates.")

    for k, row in cand.reset_index(drop=True).iterrows():
        src = int(row["src"]); dst = int(row["dst"])
        A = get_point(points, src)
        B = get_point(points, dst)

        print(f"[{k+1}/{len(cand)}] Routing src={src} -> dst={dst} ...")

        try:
            coords14, sum14 = route_coords(BASE_2014, A, B)
        except Exception as e:
            print(f"  ❌ 2014 route failed: {e}")
            continue

        try:
            coords25, sum25 = route_coords(BASE_2025, A, B)
        except Exception as e:
            print(f"  ❌ 2025 route failed: {e}")
            continue

        t14 = safe_num(row["time_s_2014"]); t25 = safe_num(row["time_s_2025"])
        d14 = safe_num(row["distance_km_2014"]); d25 = safe_num(row["distance_km_2025"])
        dt = safe_num(row["delta_time_s"]); dd = safe_num(row["delta_distance_km"])

        meta = (
            f"OD: {src} → {dst}\n"
            f"2014: time={t14:.0f}s, dist={d14:.3f}km\n"
            f"2025: time={t25:.0f}s, dist={d25:.3f}km\n"
            f"Δ:   time={dt:+.0f}s, dist={dd:+.3f}km\n\n"
            f"/route summary (Valhalla):\n"
            f"2014: length={sum14.get('length')}, time={sum14.get('time')}\n"
            f"2025: length={sum25.get('length')}, time={sum25.get('time')}\n"
        )

        out_name = f"route_compare_{metric}_{src}_to_{dst}.html"
        out_path = os.path.join(OUT_DIR, out_name)

        make_map(A, B, coords14, coords25, meta, out_path)
        print(f"  ✅ Saved: {out_path}")

    print("\nDone. Open HTML files in:", OUT_DIR)

if __name__ == "__main__":
    # change metric="delta_distance_km" if you want to draw based on distance difference
    main(top_k=3, metric="delta_distance_km")
